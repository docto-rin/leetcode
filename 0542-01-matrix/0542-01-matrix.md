# 542. 01 Matrix

- URL: https://leetcode.com/problems/01-matrix/
- Difficulty: Medium
- Tags: Array, Dynamic Programming, Breadth-First Search, Matrix
- Notebook: https://share.solve.it.com/d/d7c7a3391f6993ecb613b3aaeb9f935d

## Step 1

### å®Ÿè£…1

- ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®é¸æŠž
  - DFSãªã„ã—BFSã§result matrixã‚’æ§‹æˆã™ã‚‹ã€‚
  - æœ€åˆã€traverseã®é–‹å§‹ç‚¹ã”ã¨ã«traverseã‚’ã—ã¦ã„ãŸãŒã€åŒã˜ç‚¹ã‚’ä½•åº¦ã‚‚è¨ªã‚Œã‚‹ç„¡é§„ãŒã‚ã‚Šã€TLEã—ãŸã€‚
    - `[[0, 1] for _ in range(10000)]`ãªã©ãŒæœ€ã‚‚è‹¦æ‰‹ãªã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã ã£ãŸã€‚
    - matå†…ã®å…¨ã¦ã®`0`ã‚’å·¦ä¸Šã‹ã‚‰é †ã«é–‹å§‹ç‚¹ã¨ã—ã¦ç‹¬ç«‹ã—ã¦traverseã™ã‚‹ã®ã§ã€å³ä¸‹ã®`1`ã»ã©ä½•åº¦ã‚‚æ›´æ–°ã—ã«ã„ãå¿…è¦ãŒã‚ã£ãŸã€‚
    - ç†æƒ³çš„ã«ã¯nearest`0`ã‹ã‚‰ã®traverseã ã‘ã§æ¸ˆã¾ã›ãŸã„ã¨ã“ã‚ã€‚
  - TLEã—ã¦ã—ã°ã‚‰ãè€ƒãˆãŸã®ã¡ã€é–‹å§‹ç‚¹ã®é›†åˆã‚’å…ˆã«ä¸å¯§ã«æ´—ã„å‡ºã—ã€ç‹¬ç«‹ã§ã¯ãªãåŒæ™‚ã«BFSã‚’ã™ã‚‹ã“ã¨ãŒå¤§äº‹ã¨ã„ã†ã“ã¨ã«æ°—ã¥ã„ãŸã€‚
- å®Ÿè£…
  - layer-wiseãªloopã‚’å«ã‚€äºŒé‡loopã§æ›¸ãBFSã€‚
- è¨ˆç®—é‡
  - Time: O(m * n)
  - Extra Space: O(m * n)

```python
class Solution:
    def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:
        if not mat or not mat[0]:
            return []
        
        num_rows = len(mat)
        num_cols = len(mat[0])

        ZERO = 0
        ONE = 1
        UNVISITED = -1
        DIRECTIONS = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        result = [[UNVISITED] * num_cols for _ in range(num_rows)]

        def is_to_visit(row, col):
            return (
                0 <= row < num_rows
                and 0 <= col < num_cols
                and result[row][col] == UNVISITED
            )

        def collect_start_points():
            """collect ONEs next to any ZERO in mat"""
            start_points = []
            for row in range(num_rows):
                for col in range(num_cols):
                    if mat[row][col] == ONE:
                        continue
                    
                    result[row][col] = 0
                    for diff_row, diff_col in DIRECTIONS:
                        next_row = row + diff_row
                        next_col = col + diff_col
                        if not is_to_visit(next_row, next_col):
                            continue
                        if mat[next_row][next_col] == ZERO:
                            continue
                        # 1 next to 0 in mat
                        start_points.append((next_row, next_col))
                        result[next_row][next_col] = 1
            return start_points
        
        def traverse(start_points):
            frontiers = start_points
            score = 1
            # score: distance from nearest 0 in mat
            while frontiers:
                next_frontiers = []
                next_score = score + 1
                for row, col in frontiers:
                    for diff_row, diff_col in DIRECTIONS:
                        next_row = row + diff_row
                        next_col = col + diff_col
                        if not is_to_visit(next_row, next_col):
                            continue
                        next_frontiers.append((next_row, next_col))
                        result[next_row][next_col] = next_score
                frontiers = next_frontiers
                score = next_score
        
        traverse(collect_start_points())
        return result

```

- åˆè¨ˆ1æ™‚é–“ç¨‹åº¦ã‹ã‹ã£ã¦ã—ã¾ã£ãŸã€‚
- æŒ¯ã‚Šè¿”ã‚Š
  - æ™‚é–“ã®ã‹ã‹ã‚Šã™ãŽã€‚
    - æ›¸ãå§‹ã‚ã‚‹å‰ã®è„³å†…ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³ãŒä¸ååˆ†ã ã¨ã‹ãˆã£ã¦æ™‚é–“ãŒã‹ã‹ã‚‹ã€‚
    - ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã‚’ã‚‚ã£ã¨ã—ã£ã‹ã‚Šè€ƒãˆãŸã„ã€‚

## Step 2

ðŸ™‹**Q:** Step 1ã®ã‚³ãƒ¼ãƒ‰ã‚’ãƒ¬ãƒ“ãƒ¥ãƒ¼ã—ã¦ã€æ”¹å–„ç‚¹ã‚’æ•™ãˆã¦ãã ã•ã„ã€‚


ðŸ¤–**A:**
ã‚³ãƒ¼ãƒ‰ã‚’æ‹è¦‹ã—ã¾ã—ãŸï¼ãƒžãƒ«ãƒã‚½ãƒ¼ã‚¹BFSã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯æ­£ã—ã„ã§ã™ã­ã€‚ã„ãã¤ã‹æ”¹å–„ç‚¹ã‚’æŒ™ã’ã¾ã™ãŒã€ã¾ãšä¸€ç•ªå¤§ããªãƒã‚¤ãƒ³ãƒˆã‹ã‚‰ï¼š

**`collect_start_points`ã®ç°¡ç•¥åŒ–ã«ã¤ã„ã¦**

ç¾åœ¨ã€ã€Œ0ã«éš£æŽ¥ã™ã‚‹1ã€ã‚’é–‹å§‹ç‚¹ã¨ã—ã¦é›†ã‚ã¦ã„ã¾ã™ãŒã€å®Ÿã¯ã€Œå…¨ã¦ã®0ã€ã‚’é–‹å§‹ç‚¹ã«ã—ã¦ç›´æŽ¥BFSã‚’å§‹ã‚ã‚‹æ–¹ãŒã‚·ãƒ³ãƒ—ãƒ«ã«ãªã‚Šã¾ã™ã€‚ã“ã†ã™ã‚‹ã¨ï¼š

```python
# ç¾åœ¨: 0ã‚’å‡¦ç† â†’ éš£æŽ¥ã™ã‚‹1ã‚’é›†ã‚ã‚‹ â†’ 1ã‹ã‚‰BFSé–‹å§‹
# ç°¡ç•¥åŒ–: å…¨ã¦ã®0ã‚’queueã«å…¥ã‚Œã‚‹ â†’ ãã“ã‹ã‚‰BFSé–‹å§‹
```

ã“ã®æ–¹æ³•ã ã¨ã€`collect_start_points`ã¨`traverse`ã‚’ä¸€ã¤ã®é–¢æ•°ã«ã¾ã¨ã‚ã‚‰ã‚Œã¾ã™ã€‚

ã“ã®ç°¡ç•¥åŒ–ã«ã¤ã„ã¦ã©ã†æ€ã„ã¾ã™ã‹ï¼Ÿè©¦ã—ã¦ã¿ãŸã„ã§ã™ã‹ã€ãã‚Œã¨ã‚‚ä»–ã®æ”¹å–„ç‚¹ã‚‚å…ˆã«èžããŸã„ã§ã™ã‹ï¼Ÿ

### å®Ÿè£…2

- é–‹å§‹ç‚¹ã¯å˜ç´”ã«`0`ã«ã—ãŸæ–¹ãŒç´ ç›´ã§ã‚ã‹ã‚Šã‚„ã™ã„ã€‚
- ä¸€éƒ¨ã®å¤‰æ•°åã‚’èª¿æ•´ã€‚

```python
class Solution:
    def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:
        if not mat or not mat[0]:
            return []
        
        num_rows = len(mat)
        num_cols = len(mat[0])

        ZERO = 0
        ONE = 1
        UNVISITED = -1
        DIRECTIONS = [(1, 0), (-1, 0), (0, 1), (0, -1)]
        distances = [[UNVISITED] * num_cols for _ in range(num_rows)]
        # distance from nearest ZERO in mat

        def is_to_visit(row, col):
            return (
                0 <= row < num_rows
                and 0 <= col < num_cols
                and distances[row][col] == UNVISITED
            )

        def collect_start_points():
            """collect ZERO points"""
            start_points = []
            for row in range(num_rows):
                for col in range(num_cols):
                    if mat[row][col] == ZERO:
                        start_points.append((row, col))
                        distances[row][col] = 0
            return start_points
        
        def traverse(start_points):
            frontiers = start_points
            distance = 0
            while frontiers:
                next_frontiers = []
                next_distance = distance + 1
                for row, col in frontiers:
                    for diff_row, diff_col in DIRECTIONS:
                        next_row = row + diff_row
                        next_col = col + diff_col
                        if not is_to_visit(next_row, next_col):
                            continue
                        next_frontiers.append((next_row, next_col))
                        distances[next_row][next_col] = next_distance
                frontiers = next_frontiers
                distance = next_distance
        
        traverse(collect_start_points())
        return distances

```

- ã‚³ãƒ¡ãƒ³ãƒˆé›†ï¼šç©º
- PR
  - https://github.com/ryosuketc/leetcode_grind75/pull/27
  - https://github.com/huyfififi/coding-challenges/pull/27

ðŸ™‹**Q:** ä¸Šè¨˜ã«ä»–ã®äººãŒè§£ã„ãŸPRã‚’ã¾ã¨ã‚ã¦ã„ã¾ã™ã€‚ãã‚Œãžã‚Œã®PRã®ä»£è¡¨çš„ãªã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³ã¨ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã‚’ãƒã‚§ãƒƒã‚¯ã—ã€PRã”ã¨ã®å†…å®¹ã‚’ç°¡æ½”ã«ã¾ã¨ã‚ã¦ãã ã•ã„ã€‚


ðŸ¤–**A:**
PRã®å†…å®¹ã‚’ã¾ã¨ã‚ã¾ã™ï¼š

---

**PR #27 (ryosuketc/leetcode_grind75)**

- **ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³**: C++ã§ã®BFSã‚¢ãƒ—ãƒ­ãƒ¼ãƒï¼ˆstep2.cppï¼‰
- **ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆ** (Apo-Matchbox):
  - å†ä»£å…¥ã—ãªã„å¤‰æ•°ã«ã¯`const`ã‚’ä»˜ã‘ã‚‹ã¨è‰¯ã„ï¼ˆä¾‹: `const int rows = mat.size();`ï¼‰

---

**PR #27 (huyfififi/coding-challenges)**

- **ã‚½ãƒªãƒ¥ãƒ¼ã‚·ãƒ§ãƒ³**: è¤‡æ•°ã®ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã‚’è©¦ã—ã¦ã„ã‚‹
  - Two-passè§£æ³•ï¼ˆstep1ï¼‰
  - å†å¸°ã«ã‚ˆã‚‹DFSï¼ˆTLEï¼‰
  - BFSã«ã‚ˆã‚‹è§£æ³•

- **ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆ** (nodchip):
  1. **åŽæŸãƒ«ãƒ¼ãƒ—ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã®ææ¡ˆ**: DFSä»¥å¤–ã«ã€åŽæŸã™ã‚‹ã¾ã§row/colã§ãƒ«ãƒ¼ãƒ—ã‚’å›žã™æ–¹æ³•ã‚‚ã‚ã‚‹ã¨ç´¹ä»‹ã€‚ãŸã ã—è¨ˆç®—é‡ãŒå¤§ãã„ãŸã‚é«˜é€Ÿãªè¨€èªžã§ãªã„ã¨TLEã«ãªã‚‹
  2. **å¤‰æ•°åã«ã¤ã„ã¦**: `row_update, col_update` ã¯ä½•ã‚’è¡¨ã™ã‹åˆ†ã‹ã‚Šã«ãã„ã€‚å˜ã« `row, col, distance = queue.popleft()` ã§è‰¯ã„
  3. **Two-passè§£æ³•ã‚’ç§°è³›**: ã‚·ãƒ³ãƒ—ãƒ«ã§è‰¯ã„ã‚¢ãƒ—ãƒ­ãƒ¼ãƒã ã¨è©•ä¾¡

- **è¨ˆç®—é‡ã®è­°è«–**: nodchipãŒæœ€æ‚ªã‚±ãƒ¼ã‚¹ã®æ™‚é–“è¨ˆç®—é‡ã«ã¤ã„ã¦ `O(mÂ²nÂ²)` ã¨è¿°ã¹ãŸãŒã€huyfififiãŒ `O(mn(m+n))` ã§ã¯ãªã„ã‹ã¨æŒ‡æ‘˜ã—ã€nodchipãŒåŒæ„

---

Two-passã‚¢ãƒ—ãƒ­ãƒ¼ãƒã¯ã‚ãªãŸã®ã‚³ãƒ¼ãƒ‰ã§ã¯ä½¿ã£ã¦ã„ãªã„ã®ã§ã€èˆˆå‘³ãŒã‚ã‚Œã°èª¿ã¹ã¦ã¿ã‚‹ä¾¡å€¤ãŒã‚ã‚Šãã†ã§ã™ã­ã€‚ä½•ã‹æ°—ã«ãªã‚‹ç‚¹ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ

### å®Ÿè£…3

- ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®æ¤œè¨Ž
  - ç§»å‹•æ–¹å‘ã‚’åˆ¶é™ã—ã¦Two-passã§ã‚„ã‚‹æ–¹æ³•ã¯å®šæ•°å€ã§é€Ÿãã†ã€‚
- è¨ˆç®—é‡
  - Time: O(m * n)
  - Extra Space: O(1)
  - Output Space: O(m * n)

```python
class Solution:
    def updateMatrix(self, mat: list[list[int]]) -> list[list[int]]:
        if not mat or not mat[0]:
            return []
        
        num_rows = len(mat)
        num_cols = len(mat[0])
        INF = num_rows + num_cols
        distances = [[INF] * num_cols for _ in range(num_rows)]

        def get_distance(row, col):
            if not (0 <= row < num_rows and 0 <= col < num_cols):
                return INF
            return distances[row][col]
        
        # path only from top or left
        for row in range(num_rows):
            for col in range(num_cols):
                if mat[row][col] == 0:
                    distances[row][col] = 0
                    continue
                top = get_distance(row - 1, col)
                left = get_distance(row, col - 1)
                distances[row][col] = min(top, left) + 1
        
        # path only from bottom or right
        for row in range(num_rows - 1, -1, -1):
            for col in range(num_cols - 1, -1, -1):
                if distances[row][col] == 0:
                    continue
                bottom = get_distance(row + 1, col)
                right = get_distance(row, col + 1)
                distances[row][col] = min(
                    distances[row][col], bottom + 1, right + 1
                    )

        return distances
```

## Step 3

[å®Ÿè£…3](#å®Ÿè£…3)

## Step 4

è‡ªåˆ†ã®PRï¼šï¼ˆè‡ªåˆ†ã®PRã¸ã®ãƒªãƒ³ã‚¯ï¼‰

ðŸ™‹**Q:** ãã‚Œãžã‚Œã®ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚³ãƒ¡ãƒ³ãƒˆã«ã¤ã„ã¦ã€ã‚‚ã†å°‘ã—è©³ã—ãæ•™ãˆã¦ãã ã•ã„ã€‚

### å®Ÿè£…4

- ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å—ã‘ã¦æ›¸ãç›´ã—
  - ï¼ˆä¿®æ­£ç‚¹ï¼‰

```python
class Solution:
    pass
```